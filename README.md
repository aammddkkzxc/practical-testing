## 주요 내용 정리
- [Practical Testing: 실용적인 테스트 가이드](https://www.inflearn.com/course/practical-testing-%EC%8B%A4%EC%9A%A9%EC%A0%81%EC%9D%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B0%80%EC%9D%B4%EB%93%9C/dashboard), [단위 테스트](https://product.kyobobook.co.kr/detail/S000001805070)를 학습하고 정리한 내용입니다

### 좋은 테스트와 TDD
- 이점
  - 리팩터링 내성, 빠른 피드백, 오류 발견
  - 프로젝트가 성장할 수록 테스트는 개발 생산성에 좋은 영향을 미친다
  - 클라이언트 관점에서 구현 가능(해피 케이스에 매몰되지 않을 수 있다)
  - 테스트 하기 쉬운 코드 고려 용이
- 주의점
  - 테스트 커버리지를 목표로 하지 말자
  - 커버리지 지표는 괜찮은 부정 지표지만 동시에 좋지 않은 긍정 지표다.
  - 너무 단순한 조회 메서드 같은 경우는 테스트 코드를 만들지 않아도 무방하다. 단 한줄이라도 비지니스와 직결된다면 (ex boolean형 판별) 실수 방지를 위해서라도 작성
- 좋은 테스트의 특징
  - 개발 주기에 통합되어 있다 (프로덕션 코드 변경될 때마다 진행)
  - 가장 중요한 부분을 대상으로 한다 (비지니스 로직)
  - 최소 유지비용, 최대 가치

### 좋은 테스트 코드를 위한 원칙

#### 1. 테스트 코드 설계 및 구현 원칙
- 명확한 테스트 이름 작성 `@DisplayName`
  - 도메인 관점에서 개발자가 아닌 사람이 봐도 이해할 수 있도록 작성
  - 테스트의 현상이나 메서드 이름이 아닌, '어떤 시나리오를 검증하는가'에 초점
  - 파일 경로처럼 변경 가능성이 높은 내용은 이름에 포함하지 않는 것이 좋다
- 핵심에 집중하는 테스트 로직
  - 하나의 테스트 메서드는 하나의 개념만 검증
  - 가독성을 위해 분기문(if/else)이나 반복문(for, while) 같은 여러 논리 구조를 포함하는 것을 피한다
- 경계값 테스트 
  - 버그가 발생하기 쉬운 경계값(Boundary)을 중심으로 테스트 케이스를 설계하여 코드의 안정성을 높인다
- 검증시의 반복문 사용
  - 검증할 케이스가 많을 때 반복문을 사용하면 코드가 간결해질 수 있다. 
  - 하지만 복잡한 반복문은 테스트의 의도를 파악하기 어렵게 만들 수 있으므로, 가독성을 해치지 않는 선에서 사용

#### 2. 테스트 가능한 코드 설계 원칙
- 테스트하기 어려운 영역 분리 
  - 실행할 때마다 결과가 바뀌는 요소(현재 시간, 랜덤 값, 사용자 입력, 전역 변수 등)를 테스트 대상 코드 내에서 직접 생성하지 않는다
  - 이러한 값들은 메서드의 매개변수로 받아오는 형태로 변경하여 외부에서 제어할 수 있도록 설계 
- private 메서드는 테스트하지 않기 
  - private 메서드는 해당 객체의 내부 구현에 해당하므로 직접 테스트하지 않는 것을 원칙 
  - 만약 private 메서드를 꼭 테스트하고 싶다는 생각이 든다면, 해당 로직을 별도의 객체로 분리해야 한다는 신호일 수 있다. (단일 책임 원칙)
- 테스트용 메서드의 보수적 추가 
  - 테스트 코드에서만 사용하기 위한 메서드는 꼭 필요한 경우에만 신중하게 추가 
  - 메서드 로직이 매우 간단하거나, 추후 프로덕션 코드에서도 사용될 가능성이 있을 때 고려해볼 수 있다 (예: size(), isEmpty())

#### 3. 테스트 환경 및 데이터 관리 원칙
- 테스트 간 독립성 보장
  - 각 테스트는 다른 테스트의 결과에 영향을 주어서는 안 된다
  - 테스트 간 공유 자원을 사용하지 않고, 실행 순서에 의존하지 않도록 독립적으로 작성
- 테스트 픽스처(Test Fixture)의 전략적 사용 
  - 정의: 테스트에 필요한 데이터나 객체의 묶음을 의미 `@BeforeEach` 등을 활용
  - 장점: 여러 테스트에서 반복되는 게시글, 사용자 생성 로직 등을 미리 준비하여 테스트 코드의 중복을 줄이고 핵심 로직에 집중할 수 있다. 
  - 주의점: 모든 테스트에 동일한 픽스처가 적용되면 테스트 간 결합도가 높아지고, 특정 테스트가 어떤 데이터를 사용하는지 파악하기 어려워질 수 있다. 수정 시 모든 테스트에 영향을 미치지 않을 때, 그리고 픽스처의 상세 구성을 몰라도 테스트 내용을 이해하는 데 문제가 없을 때 사용하는 것이 좋다.
- 테스트 픽스처(Test Fixture) 클렌징
  - deleteAll()은 레코드마다 DELETE 쿼리가 발생하여 데이터가 많을 경우 성능 저하를 유발할 수 있다. 이때 deleteAllInBatch()를 사용하는 것이 효율적 
  - Spring Batch 통합 테스트와 같이 실제 커밋이 필요한 환경에서는 `@Transactional`을 통한 롤백 전략을 사용하기 어려울 수 있으므로, 데이터 정리 전략을 신중하게 선택해야 한다
- 테스트 환경 통합 및 최적화
  - 스프링을 띄우는 환경이 조금이라도 달라지면 테스트 시 새로운 컨텍스트(ApplicationContext)를 로딩하고, 그 과정에서 많은 시간이 소요된다
  - 각 계층에 최적화된 서로 다른 테스트 환경(`@DataJpaTest`, `@SpringBootTest` 등)을 사용하여 성능적 이점을 기대하는데, 결과적으로 여러 개의 컨텍스트가 생성되는 상황을 유발할 수 있다

### 레이어드 아키텍처의 테스트 전략, 방법

애플리케이션을 여러 계층(Layer)으로 나누어 개발할 때, 각 계층의 역할과 책임에 맞는 테스트 전략을 수립하는 것은 코드의 품질과 유지보수성을 높이는 데 매우 중요

#### Presentation Layer (프리젠테이션 계층)

- 특징
  - 사용자 요청을 받아 비즈니스 계층으로 전달하고, 처리 결과를 클라이언트에게 반환
  - **기본적인 형식 검증**을 수행 (예: null 값, 빈 문자열, 데이터 타입 등)
    - 도메인 규칙과 관련된 복잡한 유효성 검증은 비즈니스 계층의 역할
  - 서비스 계층의 DTO가 컨트롤러로 직접 노출되지 않도록, 컨트롤러 전용 DTO를 서비스 DTO로 변환하여 전달하는 것을 권장(단, 포맷 변경 가능성이 거의 없다면 동일 DTO를 사용하기도 한다)
  - API 명세 자동화를 위해 RestDocs와 같은 라이브러리를 활용할 수 있다
- 테스트 방법: 슬라이스 테스트 (Slice Test)
  - `@WebMvcTest` 어노테이션을 사용하여 Presentation Layer 관련 빈(`@Controller`, `@RestController` 등)만 로드
  - `MockMvc`를 사용하여 HTTP 요청과 응답을 시뮬레이션하며 컨트롤러의 동작을 검증
  - 의존하는 하위 레이어(Business, Persistence)는 `Mockito` 프레임워크를 사용하여 가짜 객체(Mock)로 대체

#### Business Layer (비즈니스 계층)

- 특징
  - 애플리케이션의 핵심 비즈니스 로직을 구현
  - 도메인 규칙에 따른 데이터 유효성 검사를 수행
  - Persistence Layer와 상호작용하며, 트랜잭션 관리가 중요한 계층

- 테스트 방법
  - 일반적으로 Persistence Layer와 함께 통합 테스트를 진행하여 실제 데이터베이스와의 연동을 검증
  - 테스트 간 독립성을 보장하기 위해 `@BeforeEach`나 `@AfterEach`를 사용하여 테스트 데이터를 초기화(setUp) 및 정리(tearDown)
  - `@Transactional`을 사용하여 테스트 후 변경 사항을 롤백할 수 있으나, 서비스 코드 자체의 트랜잭션 동작과 혼동하지 않도록 주의해야 한다

#### Persistence Layer (데이터 접근 계층)

- 특징
  - 데이터베이스와의 상호작용(CRUD)을 담당
  - 비즈니스 로직을 포함해서는 안된다
  - 거의 단위 테스트와 비슷한 성격을 가진다
  - JPA, JDBC 등 특정 데이터 기술에 종속되지 않도록 인터페이스 기반으로 설계하는 것이 이상적이긴 하다

- 테스트 방법
  - `@DataJpaTest`: JPA 관련 설정만 로드하여 가볍게 테스트. 내부에 `@Transactional`이 포함되어 있어 테스트 후 자동 롤백.
  - `@SpringBootTest`: 전체 애플리케이션 컨텍스트를 로드하여 실제 운영 환경과 가장 유사한 통합 테스트를 진행할 수 있다. (단, `@Transactional`을 포함하지 않으므로 롤백이 필요하면 직접 추가해야 한다.)

### 주요 테스트 어노테이션

| 어노테이션           | 설명 | 주요 특징 및 주의사항                                                                                                                                                   |
|-----------------| --- |----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `@SpringBootTest` | 통합 테스트용. 모든 빈을 로드하여 실제 운영 환경과 유사한 테스트를 수행합니다 | 무겁고 테스트 시간이 오래 걸릴 수 있다                                                                                                                                         |
| `@DataJpaTest`  | JPA 슬라이스 테스트용. JPA 관련 빈(`@Repository` 등)만 로드. | - `@Transactional`이 내장되어 자동 롤백                                                                                                                                 |
| `@WebMvcTest`   | MVC 슬라이스 테스트용. Presentation Layer 관련 빈(`@Controller` 등)만 로드 | - `@Service`, `@Repository` 등은 로드되지 않으므로 `@MockBean`으로 가짜 객체를 만들어야 한다.<br>- JPA 관련 빈을 로드하지 않아 `@EnableJpaAuditing` 설정과 충돌할 수 있다. (별도 `@Configuration`으로 분리 필요) |
| `@Transactional` | 메서드 종료 시 트랜잭션을 커밋 또는 롤백 | - **테스트 코드의 `@Transactional`은 기본적으로 롤백**.<br>- `@SpringBootTest`와 함께 사용 시, 서비스 로직의 트랜잭션 동작을 정확히 검증하기 어려울 수 있으니 주의해야 한다.                                        |

#### `@Transactional(readOnly = true)`와 CQRS
- CQRS (Command Query Responsibility Segregation): 데이터 변경(Command)과 조회(Query)의 책임을 분리하는 패턴
- `@Transactional(readOnly = true)`: 조회용 서비스 메서드에 사용하여 성능을 최적화할 수 있다.
- 이를 통해 Master DB(쓰기)와 Slave DB(읽기)로 엔드포인트를 분리하여 데이터베이스 부하를 줄이는 전략을 구사할 수 있다.

### Mock/Spy 관련 어노테이션 비교

| 어노테이션          | 패키지 | 대상 | 동작 방식                                                              | 주요 사용 사례 |
|:---------------| :--- | :--- |:-------------------------------------------------------------------| :--- |
| `@Mock`        | `org.mockito` | 일반 객체 | 완전한 가짜 객체를 생성합니다. 내부 메서드는 모두 `null`이나 기본값을 반환하며, 행위를 직접 정의해야 한다.   | 순수 단위 테스트 (Spring 컨텍스트 불필요) |
| `@MockBean`    | `org.springframework.boot` | Spring Bean | Spring 컨텍스트에 등록된 실제 빈(Bean)을 가짜 객체로 대체                             | 통합 테스트 또는 슬라이스 테스트 환경 |
| `@Spy`         | `org.mockito` | 일반 객체 | 실제 객체를 감싸는 프록시 객체를 생성. 행위를 정의하지 않은 메서드는 실제 객체의 로직을 그대로 수행. (부분 모킹) | 순수 단위 테스트에서 일부 메서드만 동작을 변경하고 싶을 때 |
| `@SpyBean`     | `org.springframework.boot` | Spring Bean | Spring 컨텍스트에 등록된 실제 빈을 Spy 객체로 대체                                  | 통합/슬라이스 테스트에서 실제 빈의 일부 동작만 변경하고 싶을 때 |
| `@InjectMocks` | `org.mockito` | 테스트 대상 객체 | `@Mock` 또는 `@Spy`로 생성된 객체들을 테스트 대상 객체에 자동으로 주입                     | 순수 단위 테스트에서 의존성 주입을 간편하게 처리 |

#### `@InjectMocks` vs `@Autowired`

- `@InjectMocks`: Mockito가 관리하는 어노테이션. `@Mock`이나 `@Spy`로 만들어진 가짜 객체를 주입. Spring 컨테이너와 무관하게 동작하며, 주로 단위 테스트에서 사용
- `@Autowired`: Spring Framework가 관리하는 어노테이션. Spring 컨테이너에 등록된 실제 빈(Bean)을 주입. 통합 테스트나 실제 애플리케이션 코드에서 사용